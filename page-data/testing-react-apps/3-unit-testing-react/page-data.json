{"componentChunkName":"component---src-templates-docs-js","path":"/testing-react-apps/3-unit-testing-react","webpackCompilationHash":"83b09e4d5a6066092e1f","result":{"data":{"site":{"siteMetadata":{"title":"JavaScript Testing In And Around WordPress | Josh Pollock","docsLocation":"https://github.com/shelob9/react-testing-wordpress-book/tree/master/content"}},"mdx":{"fields":{"id":"7a1aa293-c169-5063-b946-d80d1c360c88","title":"Unit Testing React Apps","slug":"/testing-react-apps/3-unit-testing-react"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unit Testing React Apps\",\n  \"metaTitle\": \"Unit Testing React\",\n  \"metaDescription\": \"Unit testing React apps with Jest, React Test Renderer and React Testing Library\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So far we have defined a specification for our app. We have empty components that could fullfill the requirement of that specification. Now we will write tests that our components will need to pass in order to prove they meet that specification.\"), mdx(\"h2\", null, \"Unit Testing React Components With React Test Renderer\"), mdx(\"h3\", null, \"Install React Test Renderer\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"yarn add react-test-renderer\\n\")), mdx(\"h3\", null, \"Find Props\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"//DO NOT test like this.\\ntest(\\\"Component renders value\\\", () => {\\n  const value = \\\"The Value\\\";\\n  const testRenderer = TestRenderer.create(<DisplayValue value={value} />);\\n  //Get the rendered node\\n  const testInstance = testRenderer.root;\\n  //find the div and make sure it has the right text\\n  expect(testInstance.findByType(\\\"div\\\").props.children).toBe(value);\\n});\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Do This For Every Prop?\")), mdx(\"p\", null, \"FALSE. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"That Is Testing React, Not Your Application\")), mdx(\"h3\", null, \"Snapshot Testing\"), mdx(\"p\", null, \"Instead of manually searching and testing every single prop. We can use snapshot tests.\"), mdx(\"p\", null, \"Snapshots acomplish two things:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Make sure your props went to the right places.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Force your to \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"commit\"), \" to changes.\")), mdx(\"p\", null, \"Snapshot tests render components to JSON and store that JSON representation in the file system. If a future test run produces a different JSON string, the test fails.\"), mdx(\"p\", null, \"This allows you to commit to the output of a component, given a specific input. If a change to the code causes a snapshot to fail, this tells you one of two things. It could tell you that you have created a regression error. This tells you to go back and fix what you accidently broke. Aleternatively it could confirm that the change to the functionality of the component that you wanted had happened.\"), mdx(\"p\", null, \"For example, if you are assigned to change the class attribute of the input generated by a component, you would expect the diff to show a change in the snapshot reflecting the class attribute had changed. In code review, you can read snapshots to ensure they match the expected behaviour of a component, and what changes are being committed to. Or you may see changes to the snapshot that indicate undesired changes.\"), mdx(\"h4\", null, \"Create A Snapshot Test\"), mdx(\"p\", null, \"In the test file for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<DisplayValue>\"), \" component, remove those messy tests from last time and replace it with a snapshot test:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"test(\\\"Component renders correctly\\\", () => {\\n  expect(\\n    TestRenderer.create(\\n      <DisplayValue value={\\\"The Value\\\"} className={\\\"the-class-name\\\"} />\\n    ).toJSON()\\n  ).toMatchSnapshot();\\n});\\n\")), mdx(\"p\", null, \"This is less code, and it uses the component in the same way we will use it in the actual app. Unit tests are always contrived, but the more that reflects how the component is used, the more valuable the test.\"), mdx(\"h2\", null, \"Unit Testing React Apps With React Testing Library\"), mdx(\"p\", null, \"Our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<EditValue />\"), \" component will be provided a value and a function that fires when that value is changed and returns the new value.\"), mdx(\"h3\", null, \"Testing React Events\"), mdx(\"p\", null, \"We could use React Test Render's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"act()\"), \" function for these tests. Instead, we'll use a higher-level tool tool that takes away most of the complexity of interacting with rendered React components. We'll use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://testing-library.com/docs/react-testing-library/intro\"\n  }), \"React Testing Library\"), \". Testing Library's React implimentation allows us to select nodes from the rendered app, like a user would, and make assertions about them or take actions, such as fireing change events, with them.\"), mdx(\"h4\", null, \"Install React Testing Library\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"yarn add @testing-library/react\\n\")), mdx(\"h4\", null, \"Testing Change Events With React Testing Library\"), mdx(\"p\", null, \"We can \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/testing-library/testing-library-docs/pull/138#issuecomment-499571797\"\n  }), \"use React Testing Libraray to test change events\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<EditValue />\"), \" component. In these tests, instead of passing a real change handler, we will use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jestjs.io/docs/en/mock-functions\"\n  }), \"Jest's mock\"), \" function instead.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jestjs.io/docs/en/mock-functions\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"jest.fn()\")), \" are useful helpers for testing if the component interacted with the onChange function correctly. Like all mocks, they help isolate components during unit testing. Later in integration tests, we will make sure that the real onChange function behaves accordingly. Using Jest's mock utility, we \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jestjs.io/docs/en/mock-functions#mock-property\"\n  }), \"can learn about how the function was called\"), \". That's what our unit test is concerned with -- how the unit being tested uses the callback. We are not concerned with what the callback does in this test. That's a seperate unit of functionality.\"), mdx(\"h4\", null, \"Setting Up Tests With React Testing Library\"), mdx(\"p\", null, \"Let's look at how to setup our tests for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<EditValue>\"), \" with React testing library. We're still using the BDD-style with nesting from the last time we looked at this test file. Now, I've used the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jestjs.io/docs/en/api#aftereachfn-timeout\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"afterEach()\"), \" function from Jest\"), \" to run a function that resets the DOM instance we're testing with after each test. This way each unit test is isolated from each other.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"//import component to test\\nimport { EditValue } from \\\"./EditValue\\\";\\nimport {\\n   render, //test renderer\\n   cleanup, //resets the JSDOM\\n   fireEvent //fires events on nodes\\n} from \\\"@testing-library/react\\\";'\\n\\ndescribe(\\\"EditValue component\\\", () => {\\n  afterEach(cleanup); //reset JSDOM after each test\\n  it(\\\"Calls the onChange function\\\", () => {\\n    //put test here\\n  });\\n  it(\\\"Passe the right value to onChange\\\", () => {\\n    //put test here\\n  });\\n});\\n\")), mdx(\"h4\", null, \"Simulating A Change Event With React Testing Library\"), mdx(\"p\", null, \"In this test, we will render the component, as it is used in the app. We can deconstruct the function \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://testing-library.com/docs/dom-testing-library/api-queries#bylabeltext\"\n  }), \"getByLabelText\"), \" from the result of the render. We can use that to find the input the same way a user would -- by reading the label test. One hidden advantage of this is that all inputs have to have a label, which is required for the app to be accesible to screen readers.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"it(\\\"Calls the onChange function\\\", () => {\\n  //mock function to test with\\n  const onChange = jest.fn();\\n  //Render component and get back getByLabelText()\\n  const { getByLabelText } = render(\\n    <EditValue\\n      onChange={onChange}\\n      value={\\\"\\\"}\\n      className={\\\"some-class\\\"}\\n      label={'Edit Value'}\\n    />\\n  );\\n  //Get the input by label text\\n  const input getByLabelText('Edit Value');\\n  //Fire a change event on the input\\n  fireEvent.change(input, {\\n    target: { value: \\\"New Value\\\" }\\n  });\\n  //Was callback function called once?\\n  expect(onChange).toHaveBeenCalledTimes(1);\\n});\\n\")), mdx(\"p\", null, \"In this test, we render the component and then find the input by label. At this point, if the component does not have the correct structure, those lines will error out. Then we use the input -- if it exists -- to fire a change event. The actuall assertions only run if all of that actually works. Beacuse we're using the component like an end user, the errors generated by running these lines should be useful in building or fixing our component.\"), mdx(\"p\", null, \"In this test, the assertion ensures that the callback is called once. If it's not called at all, that means the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" callback is probably not bound properly. If it gets called more than once, that indicates a bug, probably a bad race condition.\"), mdx(\"p\", null, \"This test does \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" prove that the right value is passed to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" prop. I want to pass a string, not the event object:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"it(\\\"Passes the right value to onChange\\\", () => {\\n  const onChange = jest.fn();\\n  const { getByLabelText } = render(\\n    <EditValue\\n      onChange={onChange}\\n      value={\\\"\\\"}\\n      className={\\\"some-class\\\"}\\n      label={'Edit Value'}\\n    />\\n  );\\n  const input getByLabelText('Edit Value');\\n  //Fire a change event on the input\\n  fireEvent.change(input, {\\n    target: { value: \\\"New Value\\\" }\\n  });\\n  //Was the new value -- not event object -- sent?\\n  expect(onChange).toHaveBeenCalledWith(\\\"New Value\\\");\\n});\\n\")), mdx(\"p\", null, \"This test is almost identical. One school of thaught says one assetrtion per unit, that way you know exactly what a failure indicates. This is following that rule. Beacuse the first argument of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"it()\"), \" is a description of the test, it makes reading test results really nice.\"), mdx(\"p\", null, \"Also, it's a ton of code duplication. A less orthodox approach says test the interaction toghether. For integration or acceptance tests, I think that's super valid. For unit tests like this, I like this way. That is a very loosley held opinion.\"), mdx(\"h4\", null, \"Snapshot Testing With React Testing Library\"), mdx(\"p\", null, \"We can also use React testing library for snapshot testing. It's very simple:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"it(\\\"matches snapshot\\\", () => {\\n  expect(\\n    render(\\n      <EditValue\\n        onChange={jest.fn()}\\n        value={\\\"Hi Roy\\\"}\\n        id={\\\"some-id\\\"}\\n        className={\\\"some-class\\\"}\\n      />\\n    )\\n  ).toMatchSnapshot();\\n});\\n\")), mdx(\"h2\", null, \"Discovering Component API\"), mdx(\"p\", null, \"So far we have tests, but not components. In the tests, we're assuming props these components do not have. That's intentional. The tests show how the component will have to work. The tests are showing us how the components should work. We're learning how to write the components from the tests. That's a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stackoverflow.com/a/584732/1469799\"\n  }), \"SOLID\"), \" strategy.\"), mdx(\"p\", null, \"We can not be sure that the props are correct until we see how the components integrate toghether. Integration tests, which use the same tools as unit tests, in different ways are next.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#unit-testing-react-components-with-react-test-renderer","title":"Unit Testing React Components With React Test Renderer","items":[{"url":"#install-react-test-renderer","title":"Install React Test Renderer"},{"url":"#find-props","title":"Find Props"},{"url":"#snapshot-testing","title":"Snapshot Testing","items":[{"url":"#create-a-snapshot-test","title":"Create A Snapshot Test"}]}]},{"url":"#unit-testing-react-apps-with-react-testing-library","title":"Unit Testing React Apps With React Testing Library","items":[{"url":"#testing-react-events","title":"Testing React Events","items":[{"url":"#install-react-testing-library","title":"Install React Testing Library"},{"url":"#testing-change-events-with-react-testing-library","title":"Testing Change Events With React Testing Library"},{"url":"#setting-up-tests-with-react-testing-library","title":"Setting Up Tests With React Testing Library"},{"url":"#simulating-a-change-event-with-react-testing-library","title":"Simulating A Change Event With React Testing Library"},{"url":"#snapshot-testing-with-react-testing-library","title":"Snapshot Testing With React Testing Library"}]}]},{"url":"#discovering-component-api","title":"Discovering Component API"}]},"parent":{"__typename":"File","relativePath":"testing-react-apps/3-unit-testing-react.md"},"frontmatter":{"metaTitle":"Unit Testing React","metaDescription":"Unit testing React apps with Jest, React Test Renderer and React Testing Library"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/about","title":"About"}}},{"node":{"fields":{"slug":"/testing-background","title":"Types of Tests"}}},{"node":{"fields":{"slug":"/","title":"JavaScript Testing In And Around WordPress"}}},{"node":{"fields":{"slug":"/next","title":"Next Steps"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/testing-react-apps","title":"Testing React Apps"}}},{"node":{"fields":{"slug":"/testing-background/3-integration-tests","title":"Integration Tests"}}},{"node":{"fields":{"slug":"/testing-background/2-unit-tests","title":"Unit Tests"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks","title":"Testing WordPress Blocks"}}},{"node":{"fields":{"slug":"/testing-background/4-acceptance-tests","title":"Acceptance Tests"}}},{"node":{"fields":{"slug":"/testing-react-apps/4-integration-testing-react-apps","title":"Integration Testing React Apps"}}},{"node":{"fields":{"slug":"/testing-react-apps/5-writing-tdd-react-components","title":"Writing Test Driven React Components"}}},{"node":{"fields":{"slug":"/testing-react-apps/2-questions-and-specs","title":"Questions and Scopes"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/2-setting-up","title":"Creating A WordPress Plugin Using WordPress Scripts"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/5-writing-tdd-blocks","title":"Test-Driven Gutenberg Blocks"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/3-structure","title":"Structuring  WordRress Plugin For Testablity"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/4-writing-block-tests","title":"Wrting Tests For WordPress Blocks"}}},{"node":{"fields":{"slug":"/testing-react-apps/3-unit-testing-react","title":"Unit Testing React Apps"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"7a1aa293-c169-5063-b946-d80d1c360c88"}}}