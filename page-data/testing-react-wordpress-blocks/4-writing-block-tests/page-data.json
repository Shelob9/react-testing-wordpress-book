{"componentChunkName":"component---src-templates-docs-js","path":"/testing-react-wordpress-blocks/4-writing-block-tests","webpackCompilationHash":"20bbf8f542dd55205dc4","result":{"data":{"site":{"siteMetadata":{"title":"JavaScript Testing In And Around WordPress | Josh Pollock","docsLocation":"https://github.com/shelob9/react-wordpress-testing/tree/master/content"}},"mdx":{"fields":{"id":"861615d8-8e08-5a92-be74-74b510a00ab7","title":"Wrting Tests For WordPress Blocks","slug":"/testing-react-wordpress-blocks/4-writing-block-tests"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Wrting Tests For WordPress Blocks\",\n  \"metaTitle\": \"Wrting Tests For WordPress Blocks\",\n  \"metaDescription\": \"desc\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Now that we have a block plugin, with the begining of components, let's write some tests that prove that the components will work as expected.\"), mdx(\"h2\", null, \"Testing The Save Callback In A Block\"), mdx(\"p\", null, \"Let's start with the save callback, this one is pretty simple, there are no interactions to test. A snapshot test will do. Be careful though, this snapshot test will pass without building out the component. Other tests will cover that it has the right structure.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"//src/components/Save.test.ks\\nimport {Save} from './save';\\nimport {\\n   render, //test renderer\\n   cleanup, //resets the JSDOM\\n   fireEvent //fires events on nodes\\n} from \\\"@testing-library/react\\\";'\\n\\ndescribe(\\\"Save componet\\\", () => {\\n  afterEach(cleanup);\\n  //It handles having no saved attribute\\n  it(\\\"matches snapshot with value attribute empty\\\", () => {\\n    const attributes = { value: '' };\\n    expect(\\n      render(\\n        <Save\\n          {...{\\n            attributes,\\n            clientId: \\\"random-id\\\",\\n            className: \\\"wp-blocks-whatever\\\",\\n          }}\\n        />\\n      )\\n    ).toMatchSnapshot();\\n  });\\n\\n  //Does it render correctly when attribute has value?\\n  it(\\\"matches snapshot with provided attribute\\\", () => {\\n    const attributes = { value: \\\"Tomorrow\\\" };\\n    expect(\\n      render(\\n        <Save\\n          {...{\\n            attributes,\\n            clientId: \\\"random-id\\\",\\n            className: \\\"wp-blocks-whatever\\\",\\n          }}\\n        />\\n      )\\n    ).toMatchSnapshot();\\n  });\\n});\\n\")), mdx(\"h2\", null, \"Testing The Edit Callback\"), mdx(\"p\", null, \"For this component, we need to make sure that\\nthe provided value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"attributes.value\"), \" is passed to the input. More importanly, when the input changes, we need to make sure that that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setAttributes()\"), \" gets that value.\"), mdx(\"p\", null, \"Remember that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setAttributes()\"), \" has the same API as\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.setState()\"), \". Also, we can mock it like any other funciton. How it works does not matter to us. What matters is how we work with it.\"), mdx(\"p\", null, \"This test is going to be very similar to the one for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<EditValue>\"), \" component. We render the interface, we check the value, we fire a change event on the input and then we check that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setAttributes()\"), \" was called once, with the right value.\"), mdx(\"p\", null, \"First, we can test the intial render with a snapshot:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"describe(\\\"Editor componet\\\", () => {\\n  afterEach(cleanup);\\n  it(\\\"matches snapshot\\\", () => {\\n    const attributes = { value: \\\"Hi Roy\\\" };\\n    const setAttributes = jest.fn();\\n    expect(\\n      render(\\n        <Editor\\n          {...{\\n            attributes,\\n            setAttributes,\\n            clientId: \\\"random-id\\\",\\n            className: \\\"wp-blocks-whatever\\\"\\n          }}\\n        />\\n      )\\n    ).toMatchSnapshot();\\n  });\\n});\\n\")), mdx(\"p\", null, \"That is a good first step, but does not test the interactivity of the block. Let's add another test for that:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"describe(\\\"Editor componet\\\", () => {\\n  afterEach(cleanup);\\n  it(\\\"matches snapshot\\\", () => {\\n    //...\\n  });\\n  it(\\\"Changes value\\\", () => {\\n    //Mock intial attributes\\n    const attributes = { value: \\\"Hi Roy\\\" };\\n    //Mock set attributes\\n    const setAttributes = jest.fn();\\n\\n    //render component\\n    const {getByLabel} = render(\\n      <Editor\\n        {...{\\n          attributes,\\n          setAttributes,\\n          clientId: \\\"random-id\\\",\\n          className: \\\"wp-blocks-whatever\\\"\\n        }}\\n      />\\n    );\\n\\n    //Get the input by label text\\n    const input getByLabelText('Edit Value');\\n    //Fire a change event on the input\\n    fireEvent.change(input, {\\n      target: { value: \\\"New Value\\\" }\\n    });\\n\\n    //Was callback function called once?\\n    expect(onChange).toHaveBeenCalledTimes(1);\\n\\n    //Was the new value -- not event object -- sent?\\n    expect(onChange).toHaveBeenCalledWith(\\\"New Value\\\");\\n  });\\n});\\n\")), mdx(\"p\", null, \"This test ensures that we're passing down the props to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<EditValue>\"), \" component properly. It's mainly copied from that component's tests.\"), mdx(\"p\", null, \"Commit those tests. They will fail of course. Time to make the components actually work.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#testing-the-save-callback-in-a-block","title":"Testing The Save Callback In A Block"},{"url":"#testing-the-edit-callback","title":"Testing The Edit Callback"}]},"parent":{"__typename":"File","relativePath":"testing-react-wordpress-blocks/4-writing-block-tests.md"},"frontmatter":{"metaTitle":"Wrting Tests For WordPress Blocks","metaDescription":"desc"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/about","title":"About"}}},{"node":{"fields":{"slug":"/next","title":"Next Steps"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction"}}},{"node":{"fields":{"slug":"/","title":"JavaScript Testing In And Around WordPress"}}},{"node":{"fields":{"slug":"/testing-react-apps","title":"Testing React Apps"}}},{"node":{"fields":{"slug":"/testing-react-apps/5-writing-tdd-react-components","title":"Writing Test Driven React Components"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks","title":"Testing WordPress Blocks"}}},{"node":{"fields":{"slug":"/testing-background","title":"Types of Tests"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/2-setting-up","title":"Creating A WordPress Plugin Using WordPress Scripts"}}},{"node":{"fields":{"slug":"/testing-react-apps/4-integration-testing-react-apps","title":"Integration Testing React Apps"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/3-structure","title":"Structuring  WordRress Plugin For Testablity"}}},{"node":{"fields":{"slug":"/testing-background/2-unit-tests","title":"Unit Tests"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/4-writing-block-tests","title":"Wrting Tests For WordPress Blocks"}}},{"node":{"fields":{"slug":"/testing-react-apps/2-questions-and-specs","title":"Questions and Scopes"}}},{"node":{"fields":{"slug":"/testing-background/3-integration-tests","title":"Integration Tests"}}},{"node":{"fields":{"slug":"/testing-background/4-acceptance-tests","title":"Acceptance Tests"}}},{"node":{"fields":{"slug":"/testing-react-wordpress-blocks/5-writing-tdd-blocks","title":"Test-Driven Gutenberg Blocks"}}},{"node":{"fields":{"slug":"/testing-react-apps/3-unit-testing-react","title":"Unit Testing React Apps"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"861615d8-8e08-5a92-be74-74b510a00ab7"}}}