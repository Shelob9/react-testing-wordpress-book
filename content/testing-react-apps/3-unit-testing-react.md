---
title: "Unit Testing React Apps"
metaTitle: "Background"
metaDescription: "desc"
---

Words before

## Unit Testing React Components With React Test Renderer

### Install React Test Renderer

```bash
yarn add react-test-renderer
```

### Find Props

```jsx
//DO NOT test like this.
test("Component renders value", () => {
  const value = "The Value";
  const testRenderer = TestRenderer.create(<DisplayValue value={value} />);
  //Get the rendered node
  const testInstance = testRenderer.root;
  //find the div and make sure it has the right text
  expect(testInstance.findByType("div").props.children).toBe(value);
});
```

**Do This For Every Prop?**

FALSE. **That Is Testing React, Not Your Application**

### Snapshot Testing

Snapshots acomplish two things:

- Make sure your props went to the right places.
- Force your to **commit** to changes.

Snapshot tests render components to JSON and store that JSON representation in the file system. If a future test run produces a different JSON string, the test fails.

This allows you to commit to the output of a component, given a specific input. If a change to the code causes a snapshot to fail, this tells you one of two things. It could tell you that you have created a regression error. This tells you to go back and fix what you accidently broke. Aleternatively it could confirm that the change to the functionality of the component that you wanted had happened.

For example, if you are assigned to change the class attribute of the input generated by a component, you would expect the diff to show a change in the snapshot reflecting the class attribute had changed. In code review, you can read snapshots to ensure they match the expected behaviour of a component, and what changes are being committed to. Or you may see changes to the snapshot that indicate undesired changes.

#### Create A Snapshot Test

In the test file for the `<DisplayValue>` component, remove those messy tests from last time and replace it with a snapshot test:

```javascript
test("Component renders correctly", () => {
  expect(
    TestRenderer.create(
      <DisplayValue value={"The Value"} className={"the-class-name"} />
    ).toJSON()
  ).toMatchSnapshot();
});
```

This is less code, and it uses the component in the same way we will use it in the actual app. Unit tests are always contrived, but the more that reflects how the component is used, the more valuable the test.

## Unit Testing React Apps With React Testing Library

### Testing Events

React testing library is best for this. Enzyme is an alternative.

```bash
yarn add @testing-library/react
```

---

#### Test On Change Event

```jsx
import { render, cleanup, fireEvent } from "@testing-library/react";
describe("EditValue component", () => {
  afterEach(cleanup); //reset JSDOM after each test
  it("Calls the onchange function", () => {
    //put test here
  });
  it("Has the right value", () => {
    //put test here
  });
});
```

aaa

```jsx
const onChange = jest.fn();
const { getByTestId } = render(
  <EditValue
    onChange={onChange}
    value={""}
    id={"input-test"}
    className={"some-class"}
  />
);
fireEvent.change(getByTestId("input-test"), {
  target: { value: "New Value" }
});
expect(onChange).toHaveBeenCalledTimes(1);
```

sdfsdfsdsdf

```jsx
const onChange = jest.fn();
const { getByTestId } = render(
  <EditValue
    onChange={onChange}
    value={""}
    id={"input-test"}
    className={"some-class"}
  />
);
fireEvent.change(getByTestId("input-test"), {
  target: { value: "New Value" }
});
expect(onChange).toHaveBeenCalledWith("New Value");
```

### Snapshot Testing With React Testing Library

```jsx
test("matches snapshot", () => {
  expect(
    render(
      <EditValue
        onChange={jest.fn()}
        value={"Hi Roy"}
        id={"some-id"}
        className={"some-class"}
      />
    )
  ).toMatchSnapshot();
});
```
